# 适配器
## 最少知识原则




## 适配器设计模式
适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间

### 适配器与装饰器的区别
#### 目的不同
适配器的作用是让他们的接口看起来像是别的东西，而不是像自己。因此适配器是一定会进行接口转换的。

装饰者的目的却是：扩展被包装的对象的**行为**或**责任**，装饰者本身是一种行为，通过将行为装饰（通过继承）到被装饰者身上后，
达到扩展其**行为**的目的，但却看起来依然像自己（对外仍然呈现相同的特质），而这个像自己，才是装饰一词的由来，装饰说明你只是变了，
但还能看出来你，这叫装饰！想适配器一样，都看不出是自己了，那怎么能叫装饰？

#### 功能不同
适配器的功能通常是为了数据能顺利传递过去，因此适配器越透传越好。

但是装饰者的目的确是**增添功能**！不能改变接口！

### 适配器的功能
而其功能为：
1. 实现不同的接口转换，将客户和接口绑定在一起，而不是将客户和实现绑定在一起。
2. 客户和被适配者之间是解耦的，当被适配着接口发生变化的时候，客户根本不需要感知
3. 被适配者的任意子类均可以使用该适配器。

### 适配器的实现
适配器继承自需求类型接口，并通过持有被适配者实例的方式，来对外呈现出需求类型的状态。 而整个过程中，
客户和被适配者之间是不感知的。互相还觉得对象还挺配合的，殊不知都是adapter的功劳。


## 外观模式
外观模式提供了一个**统一**的接口，用来访问子系统中的**一群接口**。外观定义了一个**高层**接口，让子系统**更容易使用**。

目的：让接口变得更简单，那么该设计模式就是外观模式！其次外观模式可以将客户从任何子系统中解耦出来！

### 外观模式的分析
1. 外观模式并没有封装的功能，其只是给客户提供了一套**傻瓜式**接口，简单粗暴，但是可能没有那么灵活和专业，
但是如果客户想要接触到底层的子系统，还是有能力接触到的。

### 外观模式的实现
1. 先让外观类使用组合的方式，拥有所有子系统。
2. 不同的外观采用不同的组合和不同的流程以及配置。
3. 用户直接调用需要的外观接口，一键式解决方案！


### 外观模式和适配器模式的区别
最大的区别不在于形式，在于意图，适配器的意图在于接口适配，而外观模式的意图在于简化接口！