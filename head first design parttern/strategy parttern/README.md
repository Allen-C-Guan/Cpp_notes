# 策略模式   

策略模式的精髓在于，将子类中特有的部分，从**虚函数(继承关系）** 变成了**接口类型的成员变量 + 调用接口的真函数**。
这种做法既可以保证超类中包含了子类中的所有相同的接口属性，也可以让子类之间的个性属性互相解耦。

在面向对象设计的过程中，类型的组合要优于继承，继承是**最为强相关的关系**， 但是组合却是**弱相关**，因为组合是将一个行为接口类和一个实体接口类组合了起来，而不是强行接收父类的一切的这种行为！ 这种设计模式通常更优于继承！方便维护，易读，过多的继承会导致继承混乱。

## 策略模式的原理
该策略模式实现的原理有两个
1. 成员变量解耦子类之间的关系
    首先我们要知道，成员变量和函数在继承体系中的最大区别在于，成员变量在子类中是互不影响的，而函数在子类之间是互相影响的。如果超类中
    的某个函数发生了变化，则所有子类都受影响，导致子类之间互相耦合。但成员变量不同，子类可以有自己特有的成员变量。

2. 接口类的成员变量可以实现子类的个性化特征
     成员变量固然是好，但是由于子类个性化的需求，需要成员变量可以有个性化的定制，因此我们将成员变量设计成接口类，而每个子类有自己
     的接口实现。而父类中只需要调用接口即可保证子类的个性被保留。
     
     通过如上两个设计，将成员变量的解耦特性 + 接口的个性化 可以将函数解耦！
     
     优点：
     1. 相比于超类的实函数
           超类如果采用实函数，则子类的个性化需要对父类进行覆盖，而如果多个子类同时拥有与父类不同的，但在子类之间确是相同的特性的时候，
           所有子类都要采用相同的方法覆盖父类，这让代码重复率高！
           更严重的是，父类的修改导致子类之间不好维护。
           而且由于你的实现是利用函数完成的，这意味着你的行为在运行的时候无法更改，因为运行时候，你不能重写函数啊！
     
     2. 相比于超类的虚函数
           这意味着所有子类都要重写父类，代码重复更严重。
           
        但我们的接口却不一样，具有相同个性的子类之间可以共用一个接口实现，且互相没有耦合。
       而且在运行的时候，我们可以重新给行为赋值来改变其行为。因为成员变量在运行的时候可以被更改！
        
      扩展：
        在这种设计模式下，当我需要扩展的时候
        只要新实现一个接口类，然后子类初始化的时候，新写一个采用这个新实现的接口类即可
        如果子类行为扩展，只要超类里多个属性，在子类里新增接口即可
        
## 为何采用智能指针而不是heap或者stack上的原始指针 

这里为什么采用unique_ptr 而不用指针呢？ 首先对于new出来的指针的弊端就不多少了，但是貌似stack上的指针也可以实现完全相同的功能啊为何我们要采用unique_ptr 而不是 stack上的指针呢？ 
这是因为，如果我们采用unique_ptr或者shared_ptr 我们可以保证，只要duck的实体类存在，则这两个指针成员变量对应的内存就一定不会被释放，但是如果你采用stack上的pointer，则会存在你pointer指向的内存已经释放了，但是你还在去调用，肯定会有问题。

这时候，你又要说，那我手动保证这些实例都有一个stack上的声明周期不就行了！那么如果你的Duck的实体类需要动态分配内存呢？你无论如何也无法保证pFly和pQuack的生存周期一致啊。

这时候，你又有个点子，你说那我可以把pfly和pQuack new出来，然后在Duck的destructor里释放掉，就可以和unique_ptr一样了啊，但是Duck的copy， move，赋值等，你要不要管，你图啥呢，直接弄个智能指针他不香么

综上所述，对于指针成员变量，除非你可以保证，成员的声明周期和本实体的声明周期是完全一致的（可以使用stack上指针），或者你对于成员变量的指针有所处理比如成员指针所指的对象一旦销毁，则成员变量指针也销毁，否则你就一定有使用已经销毁的内存的风险。
     
 
