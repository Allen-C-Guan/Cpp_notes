# 装饰者模式

## 开放-关闭设计原则
类应该对扩展开放，对修改关闭！
我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可以搭配新的行为，这样的设计具有弹性。

遵循开放-关闭原则，通常要引入新的抽象层次，增加代码的复杂度，因此要将该设计用在**最有可能改变**的位置上。

## 装饰者模式
### 基本概念
字面意思，装饰者表示将变化部分以**装饰的方式组合在主体对象上**。

#### 什么是装饰：

对于装饰者的要求就是，当一个装饰者装饰了一个主体对象后，该装饰者仍然要可以对外呈现出主体对象的特征！
因此这就要求装饰者和主体对象有相同的超类！

#### 如何使用：

外层装饰者通过递归调用内层装饰者的方式来获取最终的结果！


### 装饰者模式的继承关系
                     component
                    /         \
    concreteComponnet         Decorator
                             /        \
            concreteDecorator1        concreteDecorator2
            
            
比如：
摩卡作为主体对象类型，牛奶，奶泡，冰块等作为装饰者实体类！

### 模式分析
装饰者模式的本质在于，装饰者和主要实体之间不管嵌套组合多少次，由于具有相同的超类，
对外呈现永远是相同的类型，那么在类型兼容的情况下，不断递归求解，就可以获取最终的结果！
#### 特性分析
1. 装饰者和被装饰者有相同的超类
2. 装饰者可以通过嵌套的方式来包装一次或多次一个对象
3. 装饰者可以在被委托的装饰者之前或者之后，**加上自己的行为**，以达到特定的目的
4. 装饰者可以动态更新

#### 组合方法的分析
装饰者和主体对象之间虽然有继承关系，但是之间确是组合的关系，而非继承，这是因为
1. decrator和主体对象之间是通过组合的方式融为一体的
2. 继承只是单纯的为了让装饰者和被装饰者之间"血型相容"（类型匹配），
从而让没有被装饰过的主体和被装饰了任何层的对象之间类型是相同的，对外呈现也是相同的！

#### 缺点
装饰者模式会导致很多小类的产生，会让程序很复杂

