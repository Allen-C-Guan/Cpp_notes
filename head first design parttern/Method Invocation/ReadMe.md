# 指令模式
命令模式将"请求"封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销操作。

命令模式可以将发出请求的对象和执行请求的对象通过命令对象来进行解耦，而命令对象，就是两者沟通的桥梁。

比如顾客是发出请求的对象，而厨师是执行请求的对象，而服务员就是两者沟通的桥梁也就是命令对象。

其精髓在于：
将运算块打包（一个接收者（实际的执行者）和一组动作）成commend，从而可以将运算块进行组合，传来传去等解耦的组合操作！
## 指令模式的要点
1. commend
    1. 以"拥有"的方式，将执行者（door)和当前指令(OpenDoorCmd)绑定到一起
    2. commend 要提供执行接口(execute()， 执行方式为调用执行者来执行)供invoker使用. 
    commend只暴露一个execute给invoker来使用
2. invoker（调用者）
    1. invoker（remoteController）要接收commend（setCommend())
    2. 给出执行时机（pressedButton)
3. 接收者（执行者）
    1. 将执行动作封装一个接口，提供给commend来使用
    
这样，invoker一旦获取到了commend，在invoker想要执行的时候，通过调用commend.execute()接口
就可以执行相应的动作，invoker不需要感知谁来执行，也不需要感知如何执行。

但实际上，execute()通过调用cmd所持有的执行者(reciever)来执行的，执行细节被reciever封装在了其内部。

通过以上的流程我们发现，invoker不需要知道实现细节，变成了一个莫得感情的透传机器，他的全部工作就是接收
commend，执行commend，传的是啥invoker自己也不知道，只知道这个东西可以被execute就够了。
而实现都是由执行者封装在了内部。

## 优点
1. 灵活性
invoker由于只是莫得感情的执行机器，他才不在乎自己掌握的commend是什么呢！

比如最开始这个invoker手握的commend只是开门的命令，你也可以将其更换为核弹发射的命令，对于invoker而言，这两个命令没有任何区别，
因为invoker感知的只有cmd的execute接口，两者都提供了这个接口，那么invoker执行的方式没有任何区别！


## commend（调用者）的设计思路分析
我们对于commend的设计思路就是让commend越蠢越好！要让commend什么也不知道，只知道调用执行接口。没有任何自己的思想
是最好的。

当然你说你希望要一个聪明的commend，希望这个commend能为你的执行者分担一些工作，但这就意味着commend和执行者之间的强
耦合关系了，一但commend和执行者之间耦合，当执行者发生扩展的时候，commend就要跟着变！这意味着各种不同的执行者之间
也会在commend这个层面上互相耦合和影响，及其不利于维护！

因此记住一个准则：

越蠢的机制，越通用，耦合性越低，反之也成立！

因此机制可以蠢，因为要通用，但是这就要求真正的**实现功能的对象**要聪明，且封装性要好，从而让外界只要无脑调用你的接口，而你就可以搞定一切


## 队列请求
正如如上所说，commend模式将运算块打包（执行者和动作），传来传去，就像是一般的对象一样。现在即使在命令对象被创建许久以后，运算依然可以
被调用。甚至可以在不同线程中被调用。我们可以利用这样的特性衍生一些引用：日程安排，线程池，工作队列等。

比如队列请求（gof框架的设计模式基础）
假设有个工作队列：你在上面一端添加命令，形成**工作队列**，然后另一端是线程。我们将工作队列中的命令一个一个的取出来，放到可用的线程上，执行execute()
， 当这个调用完成以后，抛弃这个对象，再取下一个命令。

我们可以发现，**工作队列**和**线程计算工作**是完全解耦的，线程计算工作才不管自己执行的是什么命令呢！只负责一个一个的执行，执行完了就扔了。

这样做的优点在于：
能有效地把运算限制在固定数目的线程中进行。

