# 单例模式
单例模式可以确保一个类只有一个实例，并提供一个全局访问点！

## 单例模式的功能
单例模式通常用来管理**共享资源！**（数据库连接，线程池等），若要管理共享状态，则需要对共享资源的各种
状态进行维护，若维护数据有多份，则会导致数据维护的不准确！

比如A用户维护在了a类中，而B用户维护在了b类中，可别忘了，a和b均是共享资源的状态信息，
这时候产生了对同一份资源维护了两种状态，那么任意一个维护信息都是不准确的。

换句话说，对于同一份信息，只能有一份维护数据，如果这个维护数据是利用成员变量来维护的，那么这个
对象全局就只能有一个！！


比如电脑的注册表设置，我们希望你不能拥有两个注册表接口，否则当两个用户采用两个注册表接口改动同一份数据
的时候就会出现冲突！

## 单例模式的使用
单例模式的本质就是：当你需要某个单例的时候，你需要向getInstance()接口进行请求，（既不是自己获取，
也不是自我创建！），在请求之后，你所获得的这个单例对象有可能是刚刚创建的，也有可能是早就创建好的。


## Lazy单例模式的实现
1. private constructor，只有类内可以创建对象，类外无法创建
2. 提供一个全局访问接口 比如静态的getInstance()接口，静态接口具有和全局变量一样的访问方式;
3. 提供一个静态对象，比如局部静态变量，静态成员变量。

## 多线程安全
之所以会导致线程不安全是因为静态成员函数的执行在多线程中也是可以并行的，换句话说，如果两个线程
都调用了静态成员函数getInstance()，则可能会发生线程1中getInstance()还没执行完，线程2的getInstance()
也开始被调用了，而一旦这种事情发现，就可能会产生两个单例对象了！（因为线程1的getInstance()在还没
创建单例对象的时候，线程2一旦进入，线程2发现没有单例对象，就会新建一个单例对象，而实际上，线程1已经在
创建了，只是没创建完毕而已）

为了解决线程安全有两个办法：
1. 使用同步方法，但会大幅度降低效率，因为我们实际上只需要第一次获取的时候为同步模式，后续就不需要了
2. 使用eagerly单例模式
3. 加锁
## eagerly单例模式
为了解决线程安全，我们采用eagerly模式，eagerly模式的本质也比较简单，就是在程序加载的时候，就初始化好了。
这样就一定不会有线程问题，因为在程序初始化在程序运行之前！

eagerly的实现：
1. 将静态成员变量直接初始化！而不是在需要的时候初始化，这样静态成员变量就会在程序初始化的时候
就被初始化好了。

## 双重检查加锁
双重加锁在java中可以实现，通过两次检查来实现
1. volatile 保证在首次进入的时候，会进入同步区块
2. 而我们代码在去判一次null来确定是否被初始化过
这样就可以保证，只有第一次的时候是同步流程，其他的时候都是异步流程了

## 单例模式的注意事项
1. 单例模式最好不要继承
    1. 影响其单例性质：由于单例类的constructor是private的，子类想要继承就要改成public的，这就不是单例了
    2. 子类之间共享实例：单例的实现基础为静态成员变量，而静态成员变量意味着子类之间要共享同一个单例，
    那你子类的个性又有什么用呢？要想实现也可以通过子类想基类注册的方式来实现！
    
2. 与全局变量的区别
    1. 全局变量无法保证对象的单例，只是提供了全局访问的权限
    2. 许多全局变量指向小对象来造成命名空间的污染