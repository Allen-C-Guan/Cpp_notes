#include <iostream>
/*
 * *********************************  枚举类型  *********************************
 * 枚举的作用：
 * 将一组整型常量组织在一起。枚举是常量表达式。 同时枚举也是一种类型
 *
 * 限定作用域的枚举类型
 * enum class Slot { SLOT30 = 30, SLOT40 = 40, SLOT50 = 50 };
 *
 * 不限定作用域的枚举类型
 * enum Slot { SLOT30 = 30, SLOT40 = 40, SLOT50 = 50 };
 *
 * 限定作用域与不限定作用的区别：
 * 1. 限定作用域的枚举，遵循常规的作用域准则，并且在枚举类型的作用域外是不可访问的。
 *      不限定作用域的枚举的作用域和枚举类型本身的作用域是相同的！
 * 2. 不限定枚举可以自动转换成整型，因此可以直接赋值给整型
 *      限定作用域的枚举必须要用枚举来初始枚举类型
 *
 * 注意：
 * 这意味着可能会产生枚举类型命名的冲突！
 * enum A {a}; 和 enum B {a}; 两个a有相同的作用域，但命名相同，就会造成命名冲突！
 * 但 enum class C {a}; 是可以的，因为C的a的作用域与A和B是不同的。
 *
 * 规则：
 * 1. 枚举默认第一个为0，后面的依次加1，
 * 2. 如果枚举自定义了值，则后面的值如果没自定义，则依次加1
 * 3. 枚举的值不需要满足唯一性！
 * 4. 枚举的初值必须是常量表达式。
 * 5. 可以用作switch判断的条件
 * 6. 可以指定其大小，用冒号写name的后面
 *
 */

enum Color : int{
    RED
};

enum class Color2 : long{
    RED
};

void test_enum() {
    // 枚举的初始
    // 不限制的枚举
    Color c1 = RED; // 可以直接使用
    Color c2 = Color::RED; // 也可以显示的调用
//    Color c3 = 0;  // 即使类型一致，也不可以用int来初始化枚举类型
    int a = RED; // 但是从枚举到int确是可行的！！！ 这里可能涉及到类型抬升！

    // 限制的枚举
    Color2 c3 = Color2::RED; // 必须显示的调用
}
int main ()
{

}
