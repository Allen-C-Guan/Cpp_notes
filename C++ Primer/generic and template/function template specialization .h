//
// Created by Allen on 2021/7/4.
//

#ifndef C___PRIMER_FUNCTION_TEMPLATE_SPECIALIZATION_H
#define C___PRIMER_FUNCTION_TEMPLATE_SPECIALIZATION_H
#include <iostream>
#include <string>

/*
 * ****************************   函数模板特例化   **************************************
 * 模板特例化的目的在于，有时候，我们想对特定类型的实现进行特例化处理，这时候就需要模板特例化来实现。
 * 实现方法：
 * template<> void func(int a, int b)
 * 1. 声明这是个模板函数，因此要template来声明
 * 2. <> 空的尖括号表明我们会指定该模板函数的全部参数类型（必须是全部，不允许一部分）
 * 3. 在类型处，指定全部的类型。
 *
 * 注意：
 * 1. 特例化模板不会影响函数的匹配机制
 *  模板特例化不是模板的重载，而是模板实例化的一种而已！！因此模板的特例化并不会影响模板函数的匹配机制，
 *  但是当匹配程度相同的时候，依然会选择更特殊的来调用，因此
 *
 *  非模板函数 > 匹配的好的基类模板函数的特例化 > 匹配的好的基类模板函数 > 特例化模板函数但基类不给力的 > 基类不给力的基类模板
 *
 * 2. 特例化模板需要永远和普通模板绑定在一起，从而让两者可见性完全一致
 *  这是因为如果两者可见性不一致的时候，会导致编译器会用普通模板实例化一个函数，而不是采用特例化的模板
 *  因此需要声明在一个头文件中。
 *
 *  函数模板的编译器的匹配顺序！
 * (1) 普通函数，如果类型匹配，优先选中，重载解析结束；
 * (2) 如果没有普通函数匹配，那么所有的**基础函数模版**进入候选，编译器开始平等挑选，类型最匹配的，则被选中，
 *  注意，此时才会进入第(3)步继续筛选；
 * (3) 如果第(2)步里面选中了一个模版基础函数，则查找这个模版基础函数是否有*全特化版本*，如果有且类型匹配，
 * 则选中全特化版本，重载解析结束，否则使用(2)里面选中的模版函数，重载解析依然结束。
 * (4) 如果第(2)步里面没有选中任何函数基础模版，那么匹配失败，编译器会报错，程序员需要检查下代码。
 *
 * 因此我们可以看到！函数模板的特例化并不参数重载！而编译器在做函数匹配的的时候，会优先挑选基础函数模板先来筛选
 * 一旦选定了基础模板以后，才去匹配基础函数的特例化模板类型！ 因此特例化函数的匹配机制并不是完全的类型优先原则！
 * 即使你的特例化模板分明是最完美的匹配，但是由于你的基类模板不给力，导致你都没有上牌桌的机会。仅仅因为人家有个
 * 好爹！
 *
 * 这是因为函数模版的全特化版本不参与函数重载解析，并且优先级低于函数基础模版参与匹配的原因是：
 * C++标准委员会认为如果因为程序员随意写了一个函数模版的全特化版本，而使得原先的重载函数模板匹配结果发生改变
 * （也就是改变了约定的重载解析规则）是不能接受的。
 * 换句话说，这是因为，C++标准委员会认为，模板的重载要比模板的特例化重要，而模板的特例化又会打破这个优先级
 *
 *
 * 重载函数模版是一种不错的方式，重载解析过程*会平等的对待所有的*基础模版*，而且整个解析过程和普通函数重载是类似的，令人感觉很自然，
 * 符合期望，所有可见的重载函数模版都纳入重载解析规则，然后编译器从里面选出一个最合适的。
 * 特化函数模版就是一个不太直观的事情，首先，你还不能偏特化函数模版——原因是C++语言标准规定了！其次，函数模版特化后的版本还不参与重载。也就是说，
 * 任何函数模版的特化版本都*不影响重载解析过程*，这种行为可能违背了大多数人的直觉。然而，如果你写了一个非模版函数用来完全替代某函数模版的特化版本
 * （译注：函数签名一样，其实把函数模版的特化版本的模版声明去掉就变成了普通函数），这个普通函数反而会被优先选择，因为根据C++标准，普通函数总是
 * 应该认为比模版函数的匹配度要好。
 *
 * ********  类模板替代函数模板解决特例化和重载问题  ********
 * 如果你正在写一个函数模版，希望它成为一个*不会被特化*或者*重载*的唯一的函数模版，并且你在一个*类模版*中实现了这个函数模版，这可能是一个众所周知
 * 的绕过函数模版局限性和陷阱（译注：指函数模版没有偏特化和前面遇到重载解析的问题）的好办法。使用这种方法，程序员可以在类模版的基础上
 * 不受限制的使用偏特化和全特化（显示特化），并且不会影响到原始的函数模版的任何期望的动作。这样就避免了函数模版的两个限制，不能偏特化，
 * 以及某些情况下因为函数特化版本不参与重载带来的令人惊讶的的效应。至此，问题全部解决。
 * 如果你正在使用某人写的老式的函数模版（没有使用上面例子4里面使用类模版包装的方法），并且想写一个特殊情况下的重载版本，不要特化它，
 * 只要写一个相同函数签名的普通函数就可以了。
 *
 * 在下面这个例子中我们就可以发现，明明b的类型匹配更完美，但编译器却选择了c而不是b，这是因为编译器会先从a和c中挑选一个，发现c更般配
 * 以至于b连进入编译器视野的机会都没有了！
 *
 * 这就是特例化不参与函数重载机制的证明，而这一切是因为C++标准委员会认为模板重载要优于模板特例化。因此造成了模板特例化匹配机制的反
 * 直觉性！
 *
 * 参考博客：https://blog.csdn.net/magictong/article/details/48573737
 */



template<typename T>
void func(T a) {   //(a)
    std::cout << "this is (a): " << a << std::endl;
}

template<> // (b)
void func<int*>(int* a) { //
    std::cout << "this is (b): " << *a << std::endl;
}
/*
 * b是对a的特例化，因为T类型是int*，入参为int*，
 */
template<typename T> // (c)
void func(T *a) {
    std::cout << "this is (c):" << *a << std::endl;
}


//template<> // (d)
//void func<int>(int* a) {
//    std::cout << "this is (d): " << *a << std::endl;
//}

/*
 * d是对c的重载，因为类型是int，而入参类型是int*。 这里就有个问题，如果我们不写func后面的类型，我们发现b和d的形式是完全一致的，
 * 如何区分呢？就近原则。。d和c爱的金，d如果既可以是a的特例，也可以是c的特例的时候，就会是c的特例而不是a的特例
 */


int main ()
{
    int a = 10;
    func(&a);

}


#endif //C___PRIMER_FUNCTION_TEMPLATE_SPECIALIZATION_H
