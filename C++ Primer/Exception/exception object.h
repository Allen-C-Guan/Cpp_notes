#include <iostream>
#include <string>
#include <unordered_set>

/*
 * *******************************  异常处理  **************************************
 * 异常处理的机制的核心在于将问题的检测和解决过程分离开来，程序一部分负责检测，问题发生的时候传递给任务的另一个部分。
 * 这样做的好处就是，检测环节无需知道问题处理模块的细节，反之亦然。
 *
 * *****************************  抛出异常   **********************************
 * 抛出异常的**表达式的类型**与**调用链**共同决定了选择哪段**处理代码**。
 * 选择原则为：类型匹配 + 最近的处理代码，会处理抛出的异常。
 *
 * throw转移到与之匹配的catch（处理代码）处这意味着两件事
 * 1. 沿着调用链的函数会提早退出。
 * 2. 一旦开始异常处理代码，沿着调用链创建的对象将被销毁。（异常处理中，对象是会被销毁的！）
 *
 * **************************  栈展开  ****************************
 * 栈展开指的是，异常处理中的每对try 和 catch之间展开和匹配的方式和栈的方式相同，try就像{， catch就像}，异常处理这样互相嵌套的关系。
 * 当抛出异常的时候，就会从嵌套的里面，逐级匹配异常类型，内层匹配失败，则跳到外层去匹配。一旦匹配成功，则从catch的最后一个子句的后面的点
 * 继续执行代码。
 * 如果catch失败，则异常被标准库会进行捕获，并终止程序。
 *
 * 注意：
 * 1. 局部变量在跳出所在block的时候，会被自动销毁
 * 2. 如果异常出现在constructor内，则程序员需要自己保证已经构造的内容也可以被正确的销毁！！
 * 3. 析构函数的执行不受异常抛出的影响，换句话说，析构函数总能得到执行！
 * 4. 析构函数不能抛出自己处理不了的异常，换句话说，析构函数不能让外界看到任何异常，要么自己吃掉，要么别抛异常！！
 *
 * **********************   异常对象  *************************
 * 异常对象被存放在特殊的编译器管理的空间中，编译器可以保证任意catch语句都可以获取到该对象，并在处理完后被销毁。
 * 因此，异常对象必须可析构，可copy或者move。
 *
 * 注意：
 * 1. 局部对象的析构发生在catch之前，因此不要试图抛出指向局部变量的指针！
 * 2. 抛出的表达式的实际类型永远与静态类型保持一致，不会存在多态的情况，静态动态类型不一致的时候，会发生cut off。
 * 3. 函数类型和数组类型会退化为指针类型。
 *
 * *****************************   捕获异常  **********************************
 * 类型要求: 异常类型必须是左值引用或者值传递，不可以是右值引用
 * 异常的传递：传递方式和实参的传递相同，如果是值传递就是copy，引用就是引用
 * 继承与传递：如果以值传递的情况下，从子类到基类会造成截断，如果以引用传递的情况下，会以常规的方式进行绑定（既父类绑定到子类上，此时只能用父类有的成员）
 *
 * 查找匹配的处理代码
 * 异常的捕获是根据代码运行顺序，从前向后进行匹配的，一旦匹配成功，后面的就不会继续匹配了，异常就算处理完了。因此在安排catch的结构顺序的时候，
 * 要合理。
 * 注意：
 * 1. 我们要保证专门的catch要在整个catch列表的前面，也应该在catch嵌套层的内层
 * 2. 异常处理的匹配比类型匹配更加的严格，该匹配只允许如下三种类型转换：
 *      1). const到non_const的转换
 *      2). 派生到基类的转换
 *      3). 数组和函数到指针的转换
 *    除此之外的任何类型转换都是不允许的。（类类型的转换，算数类型的匹配等）
 *
 * ****************  重新抛出  *****************
 * 重新抛出的目的是：一条单独的catch可能不能完整的处理某个异常，需要重新抛出以后，给后面（外层）的去catch去处理。
 *
 * 使用方法：
 *      throw;  // 抛出一个空的语句，表示将当前的异常对象沿着调用链向上传递。
 *
 * 异常的更改：
 * catch中如果异常是引用，如果对异常进行了修改，则throw中抛出的异常就是修改后的异常对象。
 * 如果catch是异常的值传递，如果对异常进行了修改，则throw出去的异常是修改前的异常。
 *
 * ************ 捕获所有异常  ***************
 * 如果我们想捕获任何异常，我们可以采用catch(...)的方法捕获，该方法可以捕获任意类型的异常。
 * try {
 *  }
 * catch (...) { // 这里就会抓到任何类型的异常
 *      // 这里就意味着要处理所有类型的异常。
 * }
 * 因此如果 catch(...) 的出现一定要在所有catch的最后，否则其他的catch永远不会被捕获到。
 * 
 * // TODO 18.1.3 (p689)之后的位置没看
 * 
 */




int main ()
{

}
