#include <iostream>
#include <string>
/*
 *  ************* operator 是成员函数还是普通函数的选择原则  ***********
 *  原则：
 *  1. 与给定类型的关系是否紧密！紧密 -> 成员函数
 *      比如：=, [], (), -> 必须是成员函数, 复合赋值，递增，递减，解引用等一般都是成员函数
 *  2. 是否需要保证运算的对称性！对称 -> 普通函数
 *      比如：+， - 等算术，相等性，关系和位运算，需要运算的对称性和交换律等，一般是普通函数
 *          string s2 = "hi" + s1; // 你这要是成员函数就gg了。
 *
 * ************ operator<< 的运算符的使用 ************
 * ostream &operator<< (ostream &os, const Foo &f){
 *      os << foo.a << foo.b;
 *      return os;
 * }
 * 使用原则：
 * 1。 入参第一个必须是 ostream&, ostream不允许拷贝，且函数内要修改
 * 2。入参第二个通常是const Foo&， 因为我们是print，不要修改，reference避免copy
 * 3。return type必须是 ostream&
 * 4。必须是普通函数
 *
 * **************************** 算术与关系运算符 ********************************
 * 原则：
 * 1. 允许对左侧和右侧的运算对象转换
 *      这需要，入参是const + reference的类型，否则字面值没法作为入参，也没法完成字面值的隐式转换
 * 2. 不应该改变入参，而是用局部变量来承担计算过程，并通过值传递的方式返回这个局部变量
 * 3. 如果有复合赋值，应该用符合赋值来实现算术运算关系。
 *
 * ******************************  相等运算符 ****************************
 * 原则：
 * 1. 如果需要对吧两个obj是否相等，就应该定义 operator==
 * 2. 如果定义了 operator==， 就应该可以判定一组数据中是否有重复的元素，这也是unorder_map和unorder_map去重的实现基础
 * 3. 等号应该有传递性
 * 4. 有了== 就应该有 !=
 * 5. ==和!= 只能定义一个，另一个通过调用取非来实现，否则你定义的相等计算可能会有既不相等也不不等的bug！
 *
 * ****************************  关系运算符   **************************
 * "operator<" 要具有逻辑完备性！！
 * 原则：
 * 1. 严格弱序(弱表示小），简单理解就是"正常行为的<"
 * 2. < 的逻辑不能与 == 的逻辑冲突！， 你要保证 (a < b) || (b < a) 与 != 在逻辑上是完全一致的！
 *      如果 < 的逻辑与 == 的逻辑冲突，以 == 为主，< 则不应该被定义！！
 * 例如：你有三个成员变量，但是你只在乎其中两个成员变量的大小，并且你还在重写的==，等号的判断依据是是哪个成员都相等。
 * 这时候，如果你重写的<， 则会存在 a < b 或 b < a 但却有a != b的逻辑存在！
 *
 * ****************************  下标运算符   ********************************
 * 下标运算符 operator[] ie.StrBlobPtr
 * 原则：
 * 1. 必须是成员函数
 * 2. 必须return引用类型
 * 3. 必须提供const与non const两个版本的。
 *      当整个集合都是const的时候，由于non-const返回的是no-const的引用，会导致元素的不可访问。
 * tips:
 * 对于指针类型，C++的语法自带"[]"功能，该功能等于指针 p + index 的功能。
 *
 *
 * ***********************  前置后置运算符  **************************
 * 使用原则：ie.StrBlobPtr
 * 1. 检查是否越界，--检查在前，++检查在后
 * 2. 前置要返回reference，后置要值传递返回，且后置要把更改前的状态存储在局部变量中。
 * 3. 前置入参是空，后置入参是int，但我们不要用int
 * 4. 我们只要定义4个中的一个，就要全定义四个，且后置要通过调用前置来完成
 *
 *
 * *************************** 解引用与箭头的重载 ********************************
 * ie. StrBlobPtr
 * 解引用：
 * 解引用通常用于迭代器这种间接访问数据的类中来实现。因为解引用自身没有任何意义，且只有指针才会解引用本身，对象无法解引用自身，
 * 而且你的目的也不是为了获得迭代器本体，你是为了获取迭代器所指向的内容，这时候，解引用的使用就变得十分必要了。
 *
 * 使用原则：
 * 1. 检查被解引用的数据是否有效
 * 2. return*源数据*的引用！
 *      注意两个点，1。源数据，你返回的不是自身类型，第二是引用，这样返回值是左值，因此既可以是等号左边也可以是右边，
 *      还可以使用连续的函数调用ie.(*it).start().size();等操作
 *
 *
 * 箭头的功能与实现：
 * 箭头和解引用的调用逻辑和实现是不同的，首先箭头的调用逻辑是根据对象还是指针而进行分类讨论的，
 * 形如pointer->mem的表达式，其会根据pointer是指针还是对象，来执行如下两个步骤：
 * 1. (*pointer).mem;           // 内置类型的指针的时候
 * 2. pointer.operator()->mem   // 类对象的时候, 调用对象，然后获取他的成员mem
 *
 * 当pointer是一个指针的时候，则会等价于(*pointer).mem来使用
 *
 * 当pointer对象的时候（对象是没办法解引用），会使用pointer.operator->()获取的结果来获取mem。
 *      当获取的结果是pointer的时候，执行步骤1
 *      当获取的结果是对象的时候，并重载了operator->的时候，继续当前步骤，直到返回所需内容为止。
 *
 * 因此对于p->end()（p是StrBlobPtr的obj）的操作其实也是三步完成的，
 * 1. 调用p.operator->()来获取一个shared_ptr，然后取个shared_ptr的地址，获得一个(*string)指针;
 * 2. 对string的指针解引用，获得一个string本体。
 * 3. 获取string的成员变量end();
 *
 * 通过如上描述，我们可以发现，箭头的使用逻辑是离不开成员访问这个功能的，即你不可以pointer->的使用箭头，你后面
 * 必须跟着mem这个成员，从而实现对mem的访问！
 *
 * 箭头的使用方法
 * 1. 调用operator*()来获取本体
 * 2. 然后取其地址获得指针
 * 3. 返回指针
 *
 *
 */


class Foo
{
public:
    Foo(std::string s):s(s){};
    friend Foo operator+ (const Foo& , const Foo&);
private:
    std::string s;
};

// 算术运算的例子
Foo operator+ (const Foo &lhs, const Foo &rhs) // 必须是const + ref
{
    Foo sum = lhs; // 不能更改入参！要用局部变量 + 值传递return出去
    sum.s += rhs.s;
    return sum;
}

int main ()
{
    Foo f("allen");
    std::string other = "cecila";
    Foo f2 = f + other;
    std::string str;

}
